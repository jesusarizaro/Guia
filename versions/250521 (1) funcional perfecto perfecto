import Vision
import CoreML
import AVFoundation
import SwiftUI
import MapKit
import CoreLocation
import Combine
import AVFoundation
import Speech

let sintetizadorGlobal = AVSpeechSynthesizer()

//MARK: - Vista principal
struct ContentView: View {
    enum VistaActiva {
        case camara, destino, asistente, informacion
    }
    
    @State private var vistaActiva: VistaActiva = .asistente ///Inicia en Asistente
    @State private var decirPies: String = ""
    @State private var giro: String = ""
    @State private var mostrarOpcionesDestino = false
    @State private var respuestaDeGuia: String = "" ///respuesta del JSON que se pone en el recuadro amarillo
    @State private var respuestaParaHablar: String = "" ///se prepara la respuesta JSON para ser hablada

    @State private var destinoExpandido = false
    @State private var destinoSeleccionado = "Destino" ///seleccion del destino desde vista Destinos
    @State private var destinoDesdeServidor: String = "" ///selecciona el destino desde vista Asistente

    @StateObject private var recognizer = SpeechRecognizer()     ///reconocimiento de voz
    @StateObject private var compassManager = CompassManager()   ///brujula
    @StateObject private var locationManager = LocationManager() ///ubicaci√≥n del dispositivo
    
    @State private var grafo = Graph()
    @State private var puntosConNombre: [Vertex] = []
    @State private var grafoRuta: [Vertex] = []
    @State private var rutaAnalizada: [AristaInfo] = []
    @State private var aristaActualIndex = 0
    @State private var ultimaInstruccion = ""
    @State private var tiempoUltimaInstruccion = Date(timeIntervalSince1970: 0)
    @State private var timerDistancia: Timer?


    //let destinosDisponibles = [
    //    "Destino", "Bloque A", "Bloque B", "Bloque C",
    //    "Bloque D", "Coliseo", "Biblioteca", "Administraci√≥n", "Bloque G", "Bloque E", "Bloque F", "Bloque J", "Bloque K", "Oficina de registro", "Oficina de Financiamiento", "Oficina de Bienestar", "Puerta 7", "Puerta 4", "Puerta 11", "Bamb√∫ 1", "Bamb√∫ 2", "Coliseo",
    //]

    var body: some View {
        ZStack {
            // Vista principal din√°mica
            Group {
                switch vistaActiva {
                case .camara:
                    CameraView(vistaActiva: $vistaActiva)
                        .edgesIgnoringSafeArea(.all)
                default:
                    ZStack {
                        MapViewRepresentable(
                            ruta: grafoRuta.map { $0.coordinate },
                            userLocation: locationManager.userLocation      ///llegue hasta aquiiiiiiiiiiiiiii
                        )
                        .edgesIgnoringSafeArea(.all)
                    }
                }
            }
            
            /// recuadro de intrucciones
            if vistaActiva != .informacion {
                VStack {
                    VStack(spacing: 10) {
                        HStack {
                            if giro.contains("izquierda") {
                                Image(systemName: "arrow.turn.up.left")
                                    .foregroundColor(.white)
                            } else if giro.contains("derecha") {
                                Image(systemName: "arrow.turn.up.right")
                                    .foregroundColor(.white)
                            } else if giro.contains("adelante") {
                                Image(systemName: "arrow.up")
                                    .foregroundColor(.white)
                            } else {
                                Image(systemName: "arrow.2.circlepath")
                                    .foregroundColor(.white)
                            }
                            
                            Text(giro.isEmpty ? "Instrucci√≥n de giro:" : giro)
                                .font(.body)
                                .foregroundColor(.black)
                                .padding(10)
                                .background(Color.yellow)
                                .cornerRadius(20)
                        }
                        
                        HStack {
                            Image(systemName: "shoeprints.fill")
                                .foregroundColor(.white)
                            
                            Text(decirPies.isEmpty ? "Distancia en pies hasta tu destino:" : decirPies)
                                .font(.body)
                                .foregroundColor(.black)
                                .padding(10)
                                .background(Color.yellow)
                                .cornerRadius(20)
                        }
                    }
                    .padding()
                    .background(Color.black)
                    .cornerRadius(35)
                    .shadow(radius: 5)
                    .padding(.top, 40) // ‚¨ÖÔ∏è Ajusta seg√∫n altura del status bar
                    Spacer() // Esto empuja el bloque hacia arriba
                }
            }
            
            
            
            if vistaActiva == .destino {
                VStack {
                    Spacer()
                    
                    ZStack(alignment: .bottomTrailing) {
                        VStack(alignment: .leading, spacing: 2) {
                            Text("Selecciona un destino:")
                                .font(.footnote)
                                .foregroundColor(.black)
                            
                            if destinoExpandido {
                                // üîΩ Lista con scroll limitada a 300 px
                                ScrollView {
                                    VStack(alignment: .leading, spacing: 0) {
                                        //ForEach(destinosDisponibles, id: \.self) { destino in
                                        ForEach(puntosConNombre.compactMap { $0.name }, id: \.self) { destino in
                                            Button(action: {
                                                destinoSeleccionado = destino
                                                destinoExpandido = false
                                            }) {
                                                Text(destino)
                                                    .font(.body)
                                                    .foregroundColor(.black)
                                                    .frame(maxWidth: .infinity, alignment: .leading)
                                                    .padding(.vertical, 8)
                                            }
                                            Rectangle()
                                                .frame(height: 1)
                                                .foregroundColor(.black.opacity(0.4))
                                        }
                                    }
                                }
                                .frame(height: 300)
                            } else {
                                //Text(destinoSeleccionado)
                                Text(destinoSeleccionado.isEmpty ? "Selecciona un destino" : destinoSeleccionado)
                                    .font(.body)
                                    .fontWeight(.bold)
                                    .foregroundColor(.black)
                                    .fixedSize(horizontal: false, vertical: true)
                                    .lineLimit(nil)
                                    .frame(maxWidth: UIScreen.main.bounds.width * 0.65, alignment: .leading)
                            }
                        }
                        .padding(.horizontal, 20)
                        .padding(.top, 40)
                        .padding(.bottom, 160)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .background(Color.yellow)
                        .cornerRadius(60, corners: [.topLeft, .topRight])
                        .offset(y: 35)
                        .animation(.easeInOut(duration: 0.3), value: destinoExpandido)
                        
                        // üîÅ Bot√≥n de flecha
                        Button(action: {
                            destinoExpandido.toggle()
                        }) {
                            Image(systemName: destinoExpandido ? "arrowtriangle.down.fill" : "arrowtriangle.up.fill")
                                .font(.system(size: 25))
                                .foregroundColor(.white)
                                .padding(20)
                                .background(Color.black)
                                .clipShape(Circle())
                                .shadow(radius: 6)
                        }
                        .padding(.trailing, 30)
                        .padding(.bottom, 110)
                    }
                }
            }
            
            
            // üü° Cuadro de asistente din√°mico (solo si est√° activa la vista Asistente)
            if vistaActiva == .asistente {
                VStack {
                    Spacer()
                    // üü° Recuadro amarillo
                    ZStack(alignment: .bottomTrailing) {
                        VStack(alignment: .leading, spacing: 2) {
                            Text("Dile a Gu√≠a a d√≥nde quieres ir:")
                                .font(.footnote)
                                .foregroundColor(.black)
                            
                            Text(respuestaDeGuia.isEmpty ? "Hola, soy Gu√≠a de Uninorte." : respuestaDeGuia)
                                .font(.body)
                                .fontWeight(.bold)
                                .foregroundColor(.black)
                                .fixedSize(horizontal: false, vertical: true)
                                .lineLimit(nil)
                                .frame(maxWidth: UIScreen.main.bounds.width * 0.60, alignment: .leading)
                        }
                        .padding(.horizontal, 20)
                        .padding(.top, 40)
                        .padding(.bottom, 160)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .background(Color.yellow)
                        .cornerRadius(60, corners: [.topLeft, .topRight])
                        .offset(y: 35)
                        .animation(.easeInOut(duration: 0.3), value: vistaActiva)
                    }
                }
                
                VStack {
                    Spacer()
                    HStack {
                        Spacer()
                        Button(action: {
                            recognizer.onFinalTexto = { texto in

                                GuiaAPI.shared.enviarMensaje(texto) { respuesta, destino in
                                    self.respuestaDeGuia = respuesta
                                    self.respuestaParaHablar = prepararTextoParaHablar(respuesta)

                                    let destinoLimpio = destino.trimmingCharacters(in: .whitespacesAndNewlines)
                                    if !destinoLimpio.isEmpty {
                                        print("üìç Destino desde servidor: \(destinoLimpio)")
                                        self.destinoDesdeServidor = destinoLimpio
                                    }
                                }


                            }
                            
                            recognizer.comenzarReconocimiento()
                        }) {
                            Image(systemName: "mic.fill")
                                .font(.system(size: 25))
                                .foregroundColor(.white)
                                .padding(20)
                                .background(recognizer.estaEscuchando ? Color.red : Color.black)
                                .clipShape(Circle())
                                .shadow(radius: 6)
                        }
                        .padding(.trailing, 30)   // üîò Igual que en tu imagen
                        .padding(.bottom, 110)    // üîò Ajustado para flotar justo encima de la barra y el recuadro
                    }
                }
            }
            
            
            
            
            // üìñ Informaci√≥n
            if vistaActiva == .informacion {
                VStack {
                    VStack {
                        ScrollView {
                            VStack(alignment: .leading, spacing: 20) {
                                // T√≠tulo
                                Text("Acerca de Gu√≠a")
                                    .font(.title2)
                                    .bold()
                                    .multilineTextAlignment(.center)
                                    .frame(maxWidth: .infinity)
                                    .foregroundColor(.black)

                                // Descripci√≥n
                                Text("""
                Gu√≠a ser√° tu asistente de navegaci√≥n por el campus de la Universidad Del Norte.

                Te ayudar√° a resolver tus dudas de orientaci√≥n y te guiar√° hasta tu destino.

                ¬°Pregunta lo que sea, Gu√≠a te llevar√°!
                """)
                                    .multilineTextAlignment(.center)
                                    .frame(maxWidth: .infinity)
                                    .foregroundColor(.black)

                                Rectangle()
                                    .fill(Color.black.opacity(0.4))
                                    .frame(height: 1)
                                    .padding(.horizontal, 20)

                                // Subt√≠tulo
                                Text("Funciones")
                                    .font(.title2)
                                    .bold()
                                    .multilineTextAlignment(.center)
                                    .frame(maxWidth: .infinity)
                                    .foregroundColor(.black)

                                // Funci√≥n 1: Asistente
                                HStack(alignment: .top, spacing: 10) {
                                    Image(systemName: "person.wave.2.fill")
                                        .font(.title2)
                                        .foregroundColor(.black)
                                    VStack(alignment: .leading, spacing: 4) {
                                        Text("Con Asistente puedes conversar qu√© quieres hacer en Uninorte.")
                                            .foregroundColor(.black)
                                        Text("Ejemplos: Quiero ir a la Oficina de Registro, quiero ir a un sal√≥n en espec√≠fico, quiero hacer un intercambio, quiero comprar un helado.")
                                            .font(.footnote)
                                            .foregroundColor(.black.opacity(0.4))
                                    }
                                }

                                // Funci√≥n 2: Destinos
                                HStack(alignment: .top, spacing: 10) {
                                    Image(systemName: "map.fill")
                                        .font(.title2)
                                        .foregroundColor(.black)
                                    VStack(alignment: .leading, spacing: 4) {
                                        Text("En Destinos podr√°s seleccionar un destino establecido y Gu√≠a te asistir√° hasta tu destino.")
                                            .foregroundColor(.black)
                                    }
                                }

                                // Funci√≥n 3: C√°mara
                                HStack(alignment: .top, spacing: 10) {
                                    Image(systemName: "camera.fill")
                                        .font(.title2)
                                        .foregroundColor(.black)
                                    VStack(alignment: .leading, spacing: 4) {
                                        Text("Con C√°mara escuchar√°s qu√© tienes delante de ti.")
                                            .font(.body)
                                            .foregroundColor(.black)
                                        Text("Ejemplos: Personas, gatos, perros, sillas o carros.")
                                            .font(.footnote)
                                            .foregroundColor(.black.opacity(0.4))
                                    }
                                }

                                Rectangle()
                                    .fill(Color.black.opacity(0.4))
                                    .frame(height: 1)
                                    .padding(.horizontal, 20)

                                // Subt√≠tulo
                                Text("Instrucciones")
                                    .font(.title2)
                                    .bold()
                                    .multilineTextAlignment(.center)
                                    .frame(maxWidth: .infinity)
                                    .foregroundColor(.black)

                                Text("""
                                    Para llegar a tu destino deber√°s atender a las instrucciones de Gu√≠a.
                                """)
                                    .multilineTextAlignment(.center)
                                    .frame(maxWidth: .infinity)
                                    .foregroundColor(.black)
                                
                                
                                HStack(alignment: .top, spacing: 10) {
                                    Image(systemName: "arrow.2.circlepath")
                                        .font(.title2)
                                        .foregroundColor(.black)
                                    VStack(alignment: .leading, spacing: 4) {
                                        Text("Los giros son a la izquierda, sigue adelante, o a la derecha.")
                                            .foregroundColor(.black)
                                        Text("Los giros ser√°n de 90 grados.")
                                            .font(.footnote)
                                            .foregroundColor(.black.opacity(0.4))
                                    }
                                }
                                
                                HStack(alignment: .top, spacing: 10) {
                                    Image(systemName: "shoeprints.fill")
                                        .font(.title2)
                                        .foregroundColor(.black)
                                    VStack(alignment: .leading, spacing: 4) {
                                        Text("Los pies calculados es una aproximaci√≥n al giro m√°s cercano.")
                                            .foregroundColor(.black)
                                        Text("No es necesario que los cuentes, solamente est√° pendiente cuando falten pocos pies para tu pr√≥ximo giro.")
                                            .font(.footnote)
                                            .foregroundColor(.black.opacity(0.4))
                                    }
                                }
                                
                                
                                
                                
                                
                                
                                
                            }
                            
                            .padding()
                        }
                    }
                    .frame(height: 680) // üëà Altura definida del rect√°ngulo amarillo
                    .background(Color.yellow)
                    .cornerRadius(25)
                    .padding()

                    Spacer()
                }



            }
            
            // üîª Barra inferior con botones
            VStack {
                Spacer()
                ZStack {
                    Color.black.ignoresSafeArea(edges: .bottom)
                    
                    HStack(spacing: 50) {
                        Button(action: {
                            vistaActiva = .camara
                        }) {
                            VStack(spacing: 3) {
                                Image(systemName: "camera.fill")
                                    .font(.system(size: 25))
                                Text("C√°mara").font(.caption2)
                            }
                            .foregroundColor(.white)
                        }
                        
                        Button(action: {
                            vistaActiva = .destino
                        }) {
                            VStack(spacing: 3) {
                                Image(systemName: "map.fill")
                                    .font(.system(size: 25))
                                Text("Destinos").font(.caption2)
                            }
                            .foregroundColor(.white)
                        }
                        
                        Button(action: {
                            vistaActiva = .asistente
                        }) {
                            VStack(spacing: 3) {
                                Image(systemName: "person.wave.2.fill")
                                    .font(.system(size: 25))
                                Text("Asistente").font(.caption2)
                            }
                            .foregroundColor(.white)
                        }
                        
                        Button(action: {
                            vistaActiva = .informacion
                        }) {
                            VStack(spacing: 3) {
                                Image(systemName: "info.circle.fill")
                                    .font(.system(size: 25))
                                Text("Info").font(.caption2)
                            }
                            .foregroundColor(.white)
                        }
                    }
                    .padding(.vertical, 12)
                    .frame(maxWidth: 350)
                }
                .frame(height: 90)
            }
            

            

        }
        
        .onAppear {
            decirEnVozAlta("Hola!, soy Gu√≠a de Uninorte. A d√≥nde quieres ir") // üëã Saludo inicial
            //agregue
            cargarGrafo()
        }

        .onChange(of: respuestaParaHablar) { _, nueva in
            if !nueva.isEmpty {
                print("üó£Ô∏è Texto que se va a decir: [\(nueva)]")
                decirEnVozAlta(nueva)
            }
        }

        //agregue
        .onChange(of: destinoSeleccionado) { _, nuevo in
            calcularRuta(destino: nuevo)
        }
        //agregue
        .onChange(of: destinoDesdeServidor) { _, nuevo in
            if !nuevo.isEmpty {
                destinoSeleccionado = nuevo
                calcularRuta(destino: nuevo)
            }
        }
        //agregue
        .onReceive(locationManager.$userLocation.compactMap { $0 }) { _ in
            verificarGiros()
        }
        
    }
    
    
    
    //agregue
    func cargarGrafo() {
        grafo = GeoJSONGraphBuilder.buildGraph(from: "ComplexLayers")
        puntosConNombre = grafo.vertices.values.filter { $0.name != nil }
        if let primero = puntosConNombre.first {
            destinoSeleccionado = primero.name ?? ""
        }
    }
    
    //aguregue
    func calcularRuta(destino: String) {
        guard let gps = locationManager.userLocation else {
            return
        }
        guard let destino = grafo.vertices.values.first(where: { $0.name == destino }),
              let inicio = verticeMasCercano(a: gps),
              let ruta = grafo.shortestPath(from: inicio.coordinate, to: destino.coordinate) else {
            grafoRuta = []
            return
        }

        grafoRuta = ruta
        rutaAnalizada = []
        for i in 0..<ruta.count - 1 {
            let origen = ruta[i].coordinate
            let destino = ruta[i + 1].coordinate

            let distancia = CLLocation(latitude: origen.latitude, longitude: origen.longitude)
                .distance(from: CLLocation(latitude: destino.latitude, longitude: destino.longitude))
            let distanciaPies = distancia * 3.28084

            let deltaLat = destino.latitude - origen.latitude
            let deltaLon = destino.longitude - origen.longitude
            let radians = atan2(deltaLon, deltaLat)
            let degrees = (radians * 180 / .pi).truncatingRemainder(dividingBy: 360)
            let orientacion = (degrees >= 0) ? degrees : degrees + 360

            let info = AristaInfo(inicio: origen, fin: destino, pies: distanciaPies, orientacion: orientacion)
            rutaAnalizada.append(info)
        }
        aristaActualIndex = 0
        iniciarTimerDistancia()
    }
    
    //agregue
    func iniciarTimerDistancia() {
        timerDistancia?.invalidate()
        timerDistancia = Timer.scheduledTimer(withTimeInterval: 15.0, repeats: true) { _ in
            decirEnVozAlta(decirPies)
        }
    }
    
    //agregue
    func verificarGiros() {
        guard let ubicacionActual = locationManager.userLocation,
              aristaActualIndex < rutaAnalizada.count else { return }

        let arista = rutaAnalizada[aristaActualIndex]
        let distancia = CLLocation(latitude: ubicacionActual.latitude, longitude: ubicacionActual.longitude)
            .distance(from: CLLocation(latitude: arista.fin.latitude, longitude: arista.fin.longitude))

        decirPies = String(format: "Sigue adelante, hay %.0f pies hasta tu pr√≥ximo giro", distancia * 3.28084)

        if distancia < 3.0 {
            if aristaActualIndex < rutaAnalizada.count - 1 {
                let orientacionEsperada = rutaAnalizada[aristaActualIndex + 1].orientacion
                let orientacionUsuario = compassManager.heading
                let diferencia = normalizarAngulo(orientacionEsperada - orientacionUsuario)

                var instruccion = ""
                if diferencia > 15 {
                    instruccion = "Gira a la derecha"
                } else if diferencia < -15 {
                    instruccion = "Gira a la izquierda"
                } else {
                    instruccion = "Sigue adelante"
                }

                if instruccion != ultimaInstruccion || Date().timeIntervalSince(tiempoUltimaInstruccion) > 8 {
                    ultimaInstruccion = instruccion
                    tiempoUltimaInstruccion = Date()
                    giro = instruccion
                    decirEnVozAlta(instruccion)
                }

            } else {
                if ultimaInstruccion != "Has llegado a tu destino" {
                    ultimaInstruccion = "Has llegado a tu destino"
                    giro = "Has llegado a tu destino"
                    decirEnVozAlta("Has llegado a tu destino")
                }
            }
            aristaActualIndex += 1
        }
    }
    
    func normalizarAngulo(_ angulo: Double) -> Double {
        var a = angulo
        while a < -180 { a += 360 }
        while a > 180 { a -= 360 }
        return a
    }
    
    func verticeMasCercano(a coordenada: CLLocationCoordinate2D) -> Vertex? {
        grafo.vertices.values.min(by: {
            let d1 = CLLocation(latitude: $0.coordinate.latitude, longitude: $0.coordinate.longitude)
                .distance(from: CLLocation(latitude: coordenada.latitude, longitude: coordenada.longitude))
            let d2 = CLLocation(latitude: $1.coordinate.latitude, longitude: $1.coordinate.longitude)
                .distance(from: CLLocation(latitude: coordenada.latitude, longitude: coordenada.longitude))
            return d1 < d2
        })
    }
}








/// Almacena y recupera el thread_id
class ThreadIDManager {
    static let shared = ThreadIDManager()
    private let key = "thread_id"

    func getThreadID() -> String? {
        return UserDefaults.standard.string(forKey: key)
    }

    func setThreadID(_ id: String) {
        UserDefaults.standard.set(id, forKey: key)
    }
}










//MARK: - 6. BR√öJULA
class CompassManager: NSObject, ObservableObject, CLLocationManagerDelegate {
    private var locationManager: CLLocationManager = CLLocationManager()
    @Published var heading: Double = 0.0

    override init() {
        super.init()
        locationManager.delegate = self
        locationManager.headingFilter = kCLHeadingFilterNone
        locationManager.requestWhenInUseAuthorization()
        if CLLocationManager.headingAvailable() {
            locationManager.startUpdatingHeading()
        }
    }

    func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
        heading = newHeading.trueHeading > 0 ? newHeading.trueHeading : newHeading.magneticHeading
    }
}




//MARK: - MAPA que carga GeoJSON
struct MapViewRepresentable: UIViewRepresentable {
    /// Coordenada fija donde siempre estar√° centrado el mapa
    //var fixedCenter: CLLocationCoordinate2D
    //var altitude: CLLocationDistance = 2000  // Puedes cambiar la altura desde afuera

    //agregue
    var ruta: [CLLocationCoordinate2D]
    var userLocation: CLLocationCoordinate2D?

    func makeUIView(context: Context) -> MKMapView {
        let mapView = MKMapView()
        mapView.delegate = context.coordinator

        mapView.showsUserLocation = true      // Muestra punto azul
        mapView.mapType = .standard
        mapView.isZoomEnabled = true
        mapView.isScrollEnabled = true
        mapView.isRotateEnabled = true       // No se permite girar

        //cargarGeoJSON(en: mapView)

        return mapView
    }

    //func updateUIView(_ mapView: MKMapView, context: Context) {
        // üéØ Siempre centrado en la misma coordenada, sin rotaci√≥n
    //    let camera = MKMapCamera()
    //    camera.centerCoordinate = fixedCenter
    //    camera.heading = 0                    // üß≠ Siempre hacia el norte
    //    camera.pitch = 0
    //    camera.altitude = altitude

    //    mapView.setCamera(camera, animated: true)
    //}
    
    func updateUIView(_ mapView: MKMapView, context: Context) {
        mapView.removeOverlays(mapView.overlays)
        
        if ruta.count > 1 {
            let polyline = MKPolyline(coordinates: ruta, count: ruta.count)
            mapView.addOverlay(polyline)
            
            let region = MKCoordinateRegion(
                center: polyline.coordinate,
                latitudinalMeters: 500,
                longitudinalMeters: 500
            )
            ///estaba en true, y lo pase a false
            mapView.setRegion(region, animated: false)
        } else if let userLoc = userLocation {
            let region = MKCoordinateRegion(
                center: userLoc,
                span: MKCoordinateSpan(latitudeDelta: 0.002, longitudeDelta: 0.002)
            )
            mapView.setRegion(region, animated: false)
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator()
    }
    
    

    class Coordinator: NSObject, MKMapViewDelegate {
        func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {
            if let polyline = overlay as? MKPolyline {
                let renderer = MKPolylineRenderer(polyline: polyline)
                renderer.strokeColor = .systemBlue
                renderer.lineWidth = 4
                return renderer
            }
            return MKOverlayRenderer(overlay: overlay)
        }
    }

    //func cargarGeoJSON(en mapView: MKMapView) {
    //    guard let url = Bundle.main.url(forResource: "ComplexLayers", withExtension: "geojson"),
    //          let data = try? Data(contentsOf: url),
    //          let features = try? MKGeoJSONDecoder().decode(data) as? [MKGeoJSONFeature] else {
    //        print("‚ùå Error cargando GeoJSON.")
    //        return
    //    }

    //    for feature in features {
    //        for geometry in feature.geometry {
    //            if let polyline = geometry as? MKPolyline {
    //                mapView.addOverlay(polyline)
    //            } else if let multiPoint = geometry as? MKMultiPoint {
    //                let polyline = MKPolyline(points: multiPoint.points(), count: multiPoint.pointCount)
    //                mapView.addOverlay(polyline)
    //            }
    //        }
    //    }
    //}
}






//MARK: - GPS (modulo para tomar la informaci√≥n del gps)
class LocationManager: NSObject, ObservableObject, CLLocationManagerDelegate {
    @Published var userLocation: CLLocationCoordinate2D?
    private let locationManager = CLLocationManager()

    override init() {
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
        locationManager.distanceFilter = kCLDistanceFilterNone
        locationManager.activityType = .fitness
        locationManager.requestWhenInUseAuthorization()
        locationManager.startUpdatingLocation()
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        userLocation = locations.last?.coordinate
    }
}



//MARK: - Carga el grafo desde un archivo GeoJSON
class GeoJSONGraphBuilder {
    static func buildGraph(from nombreArchivo: String) -> Graph {
        let grafo = Graph()

        guard let url = Bundle.main.url(forResource: nombreArchivo, withExtension: "geojson"),
              let data = try? Data(contentsOf: url),
              let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let features = json["features"] as? [[String: Any]] else {
            print("‚ùå Error al leer el archivo GeoJSON")
            return grafo
        }

        for feature in features {
            guard let geometry = feature["geometry"] as? [String: Any],
                  let type = geometry["type"] as? String else { continue }

            if type == "LineString", let coords = geometry["coordinates"] as? [[Double]] {
                var prevVertex: Vertex?
                for coord in coords {
                    let punto = CLLocationCoordinate2D(latitude: coord[1], longitude: coord[0])
                    let vertice = grafo.getOrCreateVertex(for: punto)
                    if let anterior = prevVertex {
                        grafo.connect(anterior, vertice)
                    }
                    prevVertex = vertice
                }
            }

            if type == "Point", let coord = geometry["coordinates"] as? [Double] {
                let punto = CLLocationCoordinate2D(latitude: coord[1], longitude: coord[0])
                let nombre = (feature["properties"] as? [String: Any])?["name"] as? String
                _ = grafo.getOrCreateVertex(for: punto, name: nombre)
            }
        }

        return grafo
    }
}


//MARK: - Arista entre dos nodos del grafo
struct AristaInfo: Identifiable {
    let id = UUID()
    let inicio: CLLocationCoordinate2D
    let fin: CLLocationCoordinate2D
    let pies: Double
    let orientacion: Double
}

//MARK: - Nodo del grafo
class Vertex: Hashable, Identifiable {
    let id = UUID()
    let coordinate: CLLocationCoordinate2D
    var name: String?
    var neighbors: [Vertex] = []

    init(coordinate: CLLocationCoordinate2D, name: String? = nil) {
        self.coordinate = coordinate
        self.name = name
    }

    static func == (lhs: Vertex, rhs: Vertex) -> Bool {
        lhs.coordinate.latitude == rhs.coordinate.latitude &&
        lhs.coordinate.longitude == rhs.coordinate.longitude
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(coordinate.latitude)
        hasher.combine(coordinate.longitude)
    }
}

//MARK: - Grafo con algoritmo de Dijkstra
class Graph {
    var vertices: [String: Vertex] = [:]

    func key(for coordinate: CLLocationCoordinate2D) -> String {
        "\(coordinate.latitude),\(coordinate.longitude)"
    }

    func getOrCreateVertex(for coordinate: CLLocationCoordinate2D, name: String? = nil) -> Vertex {
        let k = key(for: coordinate)
        if let existente = vertices[k] {
            if let nuevoNombre = name {
                existente.name = nuevoNombre
            }
            return existente
        } else {
            let vertice = Vertex(coordinate: coordinate, name: name)
            vertices[k] = vertice
            return vertice
        }
    }

    func connect(_ v1: Vertex, _ v2: Vertex) {
        if !v1.neighbors.contains(v2) { v1.neighbors.append(v2) }
        if !v2.neighbors.contains(v1) { v2.neighbors.append(v1) }
    }

    func shortestPath(from startCoord: CLLocationCoordinate2D, to endCoord: CLLocationCoordinate2D) -> [Vertex]? {
        let start = getOrCreateVertex(for: startCoord)
        let end = getOrCreateVertex(for: endCoord)

        var distances: [Vertex: Double] = [:]
        var previous: [Vertex: Vertex] = [:]
        var unvisited: Set<Vertex> = Set(vertices.values)

        for vertex in unvisited {
            distances[vertex] = .infinity
        }
        distances[start] = 0

        while !unvisited.isEmpty {
            let current = unvisited.min { distances[$0, default: .infinity] < distances[$1, default: .infinity] }!
            unvisited.remove(current)

            if current == end {
                var path: [Vertex] = []
                var u: Vertex? = end
                while let actual = u {
                    path.insert(actual, at: 0)
                    u = previous[actual]
                }
                return path
            }

            for neighbor in current.neighbors {
                if !unvisited.contains(neighbor) { continue }
                let tentative = distances[current, default: .infinity] + distance(from: current, to: neighbor)
                if tentative < distances[neighbor, default: .infinity] {
                    distances[neighbor] = tentative
                    previous[neighbor] = current
                }
            }
        }

        return nil
    }

    private func distance(from v1: Vertex, to v2: Vertex) -> Double {
        let loc1 = CLLocation(latitude: v1.coordinate.latitude, longitude: v1.coordinate.longitude)
        let loc2 = CLLocation(latitude: v2.coordinate.latitude, longitude: v2.coordinate.longitude)
        return loc1.distance(from: loc2)
    }
}















//MARK: - CAMARA
struct CameraView: UIViewControllerRepresentable {
    @Binding var vistaActiva: ContentView.VistaActiva

    func makeUIViewController(context: Context) -> CameraViewController {
        let controller = CameraViewController()
        controller.getVistaActiva = { self.vistaActiva }
        return controller
    }
    func updateUIViewController(_ uiViewController: CameraViewController, context: Context) {
        uiViewController.getVistaActiva = { self.vistaActiva }
    }
    class CameraViewController: UIViewController, AVCaptureVideoDataOutputSampleBufferDelegate {
        var captureSession: AVCaptureSession?
        var previewLayer: AVCaptureVideoPreviewLayer?
        var lastSpokenLabel: String?
        
        var getVistaActiva: (() -> ContentView.VistaActiva)? // üëà Aqu√≠ recibimos el estado actual

    
        let etiquetasPermitidas: Set<String> = ["person", "car", "chair", "cat", "dog"]
        let traducciones: [String: String] = [
            "person": "persona", "car": "carro", "chair": "silla", "cat": "gato", "dog": "perro"
        ]
        let generos: [String: String] = [
            "persona": "f", "carro": "m", "silla": "f", "gato": "m", "perro": "m"
        ]
        
        override func viewWillAppear(_ animated: Bool) {
            super.viewWillAppear(animated)
            setupCamera() // Activamos c√°mara al entrar
        }
    
        override func viewWillDisappear(_ animated: Bool) {
            super.viewWillDisappear(animated)
            stopCamera() // Detenemos al salir
        }
    
        func setupCamera() {
            guard captureSession == nil else { return } // Evitar duplicaci√≥n
    
            captureSession = AVCaptureSession()
            captureSession?.sessionPreset = .high
    
            guard let camera = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back),
                  let input = try? AVCaptureDeviceInput(device: camera),
                  let session = captureSession else {
                print("No se pudo configurar la c√°mara.")
                return
            }
    
            if session.canAddInput(input) {
                session.addInput(input)
            }
    
            let output = AVCaptureVideoDataOutput()
            output.setSampleBufferDelegate(self, queue: DispatchQueue(label: "videoQueue"))
            if session.canAddOutput(output) {
                session.addOutput(output)
            }
    
            previewLayer = AVCaptureVideoPreviewLayer(session: session)
            previewLayer?.videoGravity = .resizeAspectFill
            previewLayer?.frame = view.bounds
            if let previewLayer = previewLayer {
                view.layer.addSublayer(previewLayer)
            }
    
            DispatchQueue.global(qos: .userInitiated).async {
                session.startRunning()
            }
        }
    
        func stopCamera() {
            captureSession?.stopRunning()
            captureSession = nil
    
            DispatchQueue.main.async {
                self.previewLayer?.removeFromSuperlayer()
                self.previewLayer = nil
            }
        }
    
        func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {
            guard let pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer) else { return }
    
            let observations = ObjectDetector.shared.detectObjects(pixelBuffer: pixelBuffer)
            DispatchQueue.main.async {
                self.drawBoundingBoxes(for: observations)
                self.announceDetectedObjects(observations)
            }
        }
    
        func drawBoundingBoxes(for observations: [VNRecognizedObjectObservation]) {
            DispatchQueue.main.async {
                self.view.layer.sublayers?.removeSubrange(1...) // Elimina todos menos el previewLayer
            }
    
            for observation in observations {
                guard let label = observation.labels.first?.identifier,
                      etiquetasPermitidas.contains(label) else { continue }
    
                let boundingBox = observation.boundingBox
                let frame = CGRect(
                    x: boundingBox.origin.x * self.view.frame.width,
                    y: (1 - boundingBox.origin.y - boundingBox.height) * self.view.frame.height,
                    width: boundingBox.width * self.view.frame.width,
                    height: boundingBox.height * self.view.frame.height
                )
    
                let boxLayer = CALayer()
                boxLayer.frame = frame
                boxLayer.borderColor = UIColor.red.cgColor
                boxLayer.borderWidth = 2.0
    
                let textLayer = CATextLayer()
                let etiquetaTraducida = traducciones[label] ?? label
                textLayer.string = etiquetaTraducida.capitalized
                textLayer.foregroundColor = UIColor.white.cgColor
                textLayer.fontSize = 14
                textLayer.frame = CGRect(x: frame.origin.x, y: frame.origin.y - 20, width: frame.width, height: 20)
                textLayer.backgroundColor = UIColor.black.withAlphaComponent(0.7).cgColor
                textLayer.alignmentMode = .center
    
                DispatchQueue.main.async {
                    self.view.layer.addSublayer(boxLayer)
                    self.view.layer.addSublayer(textLayer)
                }
            }
        }

        func announceDetectedObjects(_ observations: [VNRecognizedObjectObservation]) {
            // Solo ejecuta si estamos en la vista de c√°mara
            guard getVistaActiva?() == .camara else { return }

            // Detecta la primera observaci√≥n v√°lida
            guard let observation = observations.first(where: { etiquetasPermitidas.contains($0.labels.first?.identifier ?? "") }) else {
                lastSpokenLabel = nil
                return
            }

            // Traduce y construye el mensaje
            let originalLabel = observation.labels.first?.identifier ?? "Desconocido"
            guard etiquetasPermitidas.contains(originalLabel) else { return }

            let translatedLabel = traducciones[originalLabel] ?? originalLabel
            let genero = generos[translatedLabel] ?? "m"
            let articulo = (genero == "f") ? "una" : "un"

            let mensaje = "Tienes \(articulo) \(translatedLabel) al frente"
            let utterance = AVSpeechUtterance(string: mensaje)
            utterance.voice = AVSpeechSynthesisVoice(language: "es-CO")
            utterance.rate = 0.5

            // Espera un poquito para evitar superposiciones
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                if !sintetizadorGlobal.isSpeaking {
                    sintetizadorGlobal.speak(utterance)
                    self.lastSpokenLabel = translatedLabel
                }
            }
        }
    }
}


//MARK: - YOLO
class ObjectDetector {
    static let shared = ObjectDetector()
    private var model: VNCoreMLModel?

    private init() {
        guard let mlModel = try? YOLOv3(configuration: .init()).model,
              let visionModel = try? VNCoreMLModel(for: mlModel) else {
            print("Error al cargar el modelo ML")
            return
        }
        self.model = visionModel
    }
    
    /// Dice SOLAMENTE estas etiquetas
    let etiquetasPermitidas: Set<String> = ["person", "car", "chair", "cat", "dog"]

    /// Traduce del ingl√©s al espa√±ol las etiquetas
    let traducciones: [String: String] = [
        "person": "persona",
        "car": "carro",
        "chair": "silla",
        "cat": "gato",
        "dog": "perro"
    ]

    /// Indica el g√©nero de la palabra en espa√±ol
    let generos: [String: String] = [
        "persona": "f", // femenino
        "carro": "m",   // masculino
        "silla": "f",
        "gato": "m",
        "perro": "m"
    ]
    
    func detectObjects(pixelBuffer: CVPixelBuffer) -> [VNRecognizedObjectObservation] {
        guard let model = self.model else { return [] }
        
        let request = VNCoreMLRequest(model: model)
        let handler = VNImageRequestHandler(cvPixelBuffer: pixelBuffer, options: [:])
        
        do {
            try handler.perform([request])
            let results = request.results as? [VNRecognizedObjectObservation] ?? []

            /// Solo devuelve resultados filtrados por etiquetasPermitidas
            let filteredResults = results.filter { result in
                guard let label = result.labels.first?.identifier else { return false }
                return etiquetasPermitidas.contains(label)
            }

            return filteredResults
        } catch {
            print("Error al procesar la imagen: \(error)")
            return []
        }
    }
}


//MARK: - 5. (no se toca, funciona perfecto) COMUNICACION CON EL SERVIDOR
class GuiaAPI {
    static let shared = GuiaAPI()
    
    private let url = URL(string: "http://54.147.252.121:2500/ask")! // <- Cambia esta IP

    func enviarMensaje(_ mensaje: String, completion: @escaping (_ response: String, _ destino: String) -> Void) {
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        var json: [String: Any] = ["prompt": mensaje]
        
        // üëâ Incluir thread_id si existe
        if let threadID = ThreadIDManager.shared.getThreadID() {
            json["thread_id"] = threadID
        }

        let jsonData = try? JSONSerialization.data(withJSONObject: json)
        request.httpBody = jsonData

        URLSession.shared.dataTask(with: request) { data, response, error in
            guard let data = data else {
                print("‚ùå Sin datos: \(error?.localizedDescription ?? "error desconocido")")
                completion("No se recibi√≥ respuesta.", "")
                return
            }

            do {
                if let respuesta = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let mensajeRespuesta = respuesta["response"] as? String {

                    let destino = respuesta["destino"] as? String ?? ""
                    let nuevoThreadID = respuesta["thread_id"] as? String

                    // üëâ Guardar nuevo thread_id si no hay uno anterior
                    if ThreadIDManager.shared.getThreadID() == nil, let nuevo = nuevoThreadID {
                        ThreadIDManager.shared.setThreadID(nuevo)
                        print("üìå Nuevo thread_id guardado: \(nuevo)")
                    }

                    DispatchQueue.main.async {
                        let limpio = mensajeRespuesta.components(separatedBy: "{\"destino\"").first ?? mensajeRespuesta
                        let respuestaLimpia = limpio.trimmingCharacters(in: .whitespacesAndNewlines)
                        completion(respuestaLimpia, destino)
                    }
                } else {
                    print("‚ö†Ô∏è JSON inesperado: \(String(data: data, encoding: .utf8) ?? "sin texto")")
                    completion("Respuesta no entendida.", "")
                }
            } catch {
                print("‚ùå Error al parsear JSON: \(error.localizedDescription)")
                completion("Error al interpretar respuesta.", "")
            }
        }.resume()
    }
}

//MARK: - 4. (no se toca, funciona perfecto) DEL JSON, TOMA SOLAMENTE EL "response", LO LIMPIA Y LO PREPARA LA DICTAR
func prepararTextoParaHablar(_ texto: String) -> String {
    let limpio = texto.trimmingCharacters(in: .whitespacesAndNewlines)

    // Elimina caracteres invisibles o de control (como \u{200B}, \u{FEFF}, etc)
    let textoFiltrado = limpio.unicodeScalars.filter { scalar in
        !(CharacterSet.controlCharacters.contains(scalar) || scalar == "\u{200B}" || scalar == "\u{FEFF}")
    }

    return String(String.UnicodeScalarView(textoFiltrado))
}

//MARK: - 3. (no se toca, funciona perfecto) DICTADO POR VOZ
func decirEnVozAlta(_ texto: String) {
    let textoLimpio = texto.trimmingCharacters(in: .whitespacesAndNewlines)
    guard !textoLimpio.isEmpty else { return }

    let utterance = AVSpeechUtterance(string: textoLimpio)
    utterance.voice = AVSpeechSynthesisVoice(language: "es-CO")
    utterance.rate = 0.5

    DispatchQueue.main.async {
        do {
            let session = AVAudioSession.sharedInstance()
            try session.setCategory(.playAndRecord, mode: .default, options: [.duckOthers, .defaultToSpeaker])
            try session.setActive(true)
        } catch {
            print("‚ö†Ô∏è Error al configurar la sesi√≥n de audio: \(error)")
        }

        sintetizadorGlobal.stopSpeaking(at: .immediate)

        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            sintetizadorGlobal.speak(utterance)
        }
    }
}

//MARK: - 2. (no se toca, funciona perfecto) RECONOCIMIENTO DE VOZ
class SpeechRecognizer: NSObject, ObservableObject, SFSpeechRecognizerDelegate {
    private let recognizer = SFSpeechRecognizer(locale: Locale(identifier: "es"))!
    private var request: SFSpeechAudioBufferRecognitionRequest?
    private var recognitionTask: SFSpeechRecognitionTask?
    private let audioEngine = AVAudioEngine()

    private var silencioTimer: Timer?
    private let tiempoSilencio: TimeInterval = 1  // segundos sin hablar = silencio

    private var yaSeRespondio = false

    
    @Published var estaEscuchando = false  // üëà A√±adido
    
    @Published var textoReconocido = ""
    var onFinalTexto: ((String) -> Void)?  // Este callback se llama cuando termina

    func comenzarReconocimiento() {
        SFSpeechRecognizer.requestAuthorization { authStatus in
            guard authStatus == .authorized else {
                print("Permiso no autorizado.")
                return
            }

            DispatchQueue.main.async {
                self.estaEscuchando = true // üëÇ Comienza a escuchar
                self.empezarGrabacion()
            }
        }
    }

    func empezarGrabacion() {
        
        yaSeRespondio = false
        
        if audioEngine.isRunning {
            detenerReconocimiento()
            return
        }

        request = SFSpeechAudioBufferRecognitionRequest()
        let inputNode = audioEngine.inputNode

        guard let request = request else { return }

        request.shouldReportPartialResults = true

        recognitionTask = recognizer.recognitionTask(with: request) { result, error in
            if let result = result {
                let nuevoTexto = result.bestTranscription.formattedString
                self.textoReconocido = nuevoTexto
                self.reiniciarTimerSilencio()
            }

            if let error = error {
                print("Error: \(error.localizedDescription)")
                self.detenerReconocimiento()
            }
        }

        let formato = inputNode.outputFormat(forBus: 0)
        inputNode.installTap(onBus: 0, bufferSize: 1024, format: formato) { buffer, _ in
            self.request?.append(buffer)
        }

        audioEngine.prepare()
        try? audioEngine.start()
    }

    func detenerReconocimiento() {
        audioEngine.stop()
        request?.endAudio()
        audioEngine.inputNode.removeTap(onBus: 0)
        self.estaEscuchando = false // üîá Deja de escuchar
        reconocimientoFinalizado()
    }

    func reiniciarTimerSilencio() {
        silencioTimer?.invalidate()
        silencioTimer = Timer.scheduledTimer(withTimeInterval: tiempoSilencio, repeats: false) { _ in
            self.detenerReconocimiento()
        }
    }

    func reconocimientoFinalizado() {
        DispatchQueue.main.async {
            let textoFinal = self.textoReconocido.trimmingCharacters(in: .whitespacesAndNewlines)
            if !textoFinal.isEmpty {
                
                print("üé§ Texto reconocido final: \(textoFinal)")

                
                if !self.yaSeRespondio {
                    self.yaSeRespondio = true
                    self.onFinalTexto?(textoFinal)
                }
            }
        }
    }
}

//MARK: - 1.2 (no se toca, funciona perfecto) BORDES REDONDOS EN EL FRONT PARA EL RECUADRO AMARILLO
struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners

    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}
//MARK: - 1.1 (no se toca, funciona perfecto) BORDES REDONDOS EN EL FRONT PARA EL RECUADRO AMARILLO
extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
}
